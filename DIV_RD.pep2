           .GLOBAL  DIV
;*******************************
;***Division (Quotient and Remainder) Subprogram***
;*******************************
;**Local Variables
cycS:      .ASCII   "---Cycle Number: \x00"
subS:      .ASCII   "Subtracting... \n\x00"
setL0:     .ASCII   "LSB is 0\n\x00"
setL1:     .ASCII   "LSB is 1\n\x00"
shiftAQ:   .ASCII   "Shift AQ left\n\x00"
M:         .WORD    0               ;Divisor
A:         .WORD    0               ;Double word Dividend
Q:         .WORD    0
divisor:   .EQUATE  2               ;Divisor location on the stack
dividedA:  .EQUATE  4               ;Double Dividend location on the stack
dividedQ:  .EQUATE  6
;*******************************
DIV:       MOVE     divisor,s,M,d   ;move the stack variable to M
           MOVE     dividedA,s,A,d  ;move the stack variable to A
           MOVE     dividedQ,s,Q,d  ;move the stack variable to Q
           BINO     M,d             ;Debugging only
           CHARO    '\n',i          ;Debugging only
           BINO     A,d             ;Debugging only
           CHARO    ' ',i           ;Debugging only
           BINO     Q,d             ;Debugging only
           CHARO    '\n',i          ;Debugging only
           LDA      0,i             ;set carry to 0
           RORA                     ;
           LDA      Q,d             ;load Q into a
           ROLA                     ;roatate left so the MSB is in the carry bit and 0 is the LSB of Q
           STA      Q,d             ;store Q
           LDA      A,d             ;load A into a
           ROLA                     ;rotate left so the MSB of A is now LSB of Q
           STA      A,d             ;store a into A
           CMPU     A,d,M,d         ;unsigned compare A to M
           TSTA                     ;set status bits
           BRGE     ovrflw          ;if (A >= M) branch ovrflw
           LDA      Q,d             ;load Q
           RORA                     ;rotate Q right
           STA      Q,d             ;store Q
           LDA      0,i             ;else set carry to 0
           RORA                     ;
           LDA      Q,d             ;reload Q
           ROLA                     ;rotate Q left setting the LSB to 0
           STA      Q,d             ;store Q
           LDX      15,i            ;n-1 where n is the number of bits
loop:      CPX      0,i             ;compare loop counter to 0
           BREQ     end             ;branch if loop counter is 0
           STRO     cycS,d          ;Debugging only
           DECOX                    ;Debugging only
           CHARO    '\n',i          ;Debugging only
           BINO     A,d             ;Debugging only
           CHARO    ' ',i           ;Debugging only
           BINO     Q,d             ;Debugging only
           CHARO    '\n',i          ;Debugging only
           LDA      0,i             ;set carry to 0
           RORA                     ;
           LDA      Q,d             ;load Q into a
           ROLA                     ;roatate left so the MSB is in the carry bit and 0 is the LSB of Q
           STA      Q,d             ;store Q
           LDA      A,d             ;load A into a
           ROLA                     ;rotate left so the MSB of A is now LSB of Q
           STA      A,d             ;store A
           STRO     shiftAQ,d       ;Debugging only
           BINO     A,d             ;Debugging only
           CHARO    ' ',i           ;Debugging only
           BINO     Q,d             ;Debugging only
           CHARO    '\n',i          ;Debugging only
           SUBU     A,d,M,d         ;unsigned subtract M from A
           STA      A,d             ;store unsigned subtraction M from A to A
           CMPU     A,d,0,i         ;compare A - M to 0
           TSTA
           BRGE     set1            ;if (A - M >= 0) branch set 1
           ADD      A,d,M,d         ;A = A + M
           LDA      Q,d             ;else reload Q
           RORA                     ;rotate Q right
           STA      Q,d             ;store Q
           LDA      0,i             ;else set carry to 0
           RORA                     ;
           LDA      Q,d             ;reload Q
           ROLA                     ;rotate Q left setting the LSB to 0
           STA      Q,d             ;store Q
           STRO     setL0,d         ;Debugging only
           BINO     A,d             ;Debugging only
           CHARO    ' ',i           ;Debugging only
           BINO     Q,d             ;Debugging only
           CHARO    '\n',i          ;Debugging only
           BR       dcre
set1:      LDA      Q,d             ;reload Q
           RORA                     ;rotate Q right
           STA      Q,d             ;store Q
           LDA      1,i             ;else set carry to 1
           RORA                     ;
           LDA      Q,d             ;reload Q
           ROLA                     ;rotate Q left setting the LSB to 1
           STA      Q,d             ;store Q
           STRO     setL1,d         ;Debugging only
           BINO     A,d             ;Debugging only
           CHARO    ' ',i           ;Debugging only
           BINO     Q,d             ;Debugging only
           CHARO    '\n',i          ;Debugging only
dcre:      SUBX     1,i             ;counter--
           BR       loop            ;loop
end:       LDA      A,d             ;load A into a
           LDX      Q,d             ;load Q into x
           RET0                     ;return to calling program
ovrflw:    RET0                     ;TODO set oVerflow